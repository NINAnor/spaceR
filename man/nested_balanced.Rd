% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nested_balanced.R
\name{nested_balanced}
\alias{nested_balanced}
\title{Nested, balanced, and spatially well-spread stratified samples}
\usage{
nested_balanced(
  samplingFrame,
  n_seq,
  id_col = "ID",
  stratum_col = "stratum",
  easting_col = "Easting",
  northing_col = "Northing",
  area_col = "area",
  xbal_formula = ~1,
  exclude_offset = 1e+06,
  return_dataframe = FALSE,
  out_name = "mysample",
  quiet = FALSE
)
}
\arguments{
\item{samplingFrame}{A \code{data.frame} (your population of sampling units, e.g. \code{mypop}).}

\item{n_seq}{Numeric vector of desired \strong{per-stratum} sample sizes in
decreasing order, e.g. \code{c(100, 80, 60, 40, 20)}. The first element is the
largest (top-level) sample; each subsequent element is a nested subsample
of the previous.}

\item{id_col}{Name of the ID column in \code{samplingFrame}. Default \code{"ID"}. Needs to be unique to each population unit.}

\item{stratum_col}{Name of the stratum column in \code{samplingFrame}. Default \code{"stratum"}.}

\item{easting_col}{Name of the easting (x) coordinate column. Default \code{"Easting"}.}

\item{northing_col}{Name of the northing (y) coordinate column. Default \code{"Northing"}.}

\item{area_col}{Name of the area/size measure column used to set inclusion
probabilities within stratum (your \code{area}). Default \code{"area"}. If you are not using
sampling with probabilities proportional to size, then \code{area_col} might just be
the population or strata size \emph{N}.}

\item{xbal_formula}{A right-hand-side formula for the balancing variables,
evaluated on \code{samplingFrame}, e.g. \code{~ aux1 + aux2 - 1}. Default \code{~ 1} (no balancing
auxiliaries beyond spreading/strata).}

\item{exclude_offset}{Numeric offset added to the max of each coordinate to
push excluded units \emph{far away} for the spreading step. Default \code{1e6}.}

\item{return_dataframe}{Logical; if \code{TRUE}, also returns a filtered sampling frame, with all columns,
instead of just the population units ID's and the probabilities. Default \code{FALSE}.}

\item{out_name}{Character; text to be prepended to the sample names, followed by the sample size.
Default to 'mysample' which will name the output like 'mysample_n' where n is the sample size.}
}
\value{
A named list of lists. For each \code{n} you get an element named
\verb{mysample\{n\}} (e.g. \code{wetlands_100}, \code{wetlands_80}, ...), each containing a list of population ID's,
and a list of inclusion probabilities, which are the accumulated probabilities and the initial probabilities.
This means that if the
probability of a unit in the initial sample is 0.1, and in the second sample it was 0.9, then the accumulated
probaili is 0.09. If \code{return_dataframe = TRUE} a \code{data.frame} with the rows
of \code{samplingFrame} that were selected.
}
\description{
Draws a sequence of \strong{nested} samples per stratum that are both
probability-balanced (via \pkg{BalancedSampling}) and well-spread in space.
The first sample can also use probabilities proportional to size (pps).
The largest sample is drawn first; each subsequent (smaller) sample is drawn
\emph{from the previous sample only}, but balanced against the auxiliary variables at
the level of the whole population, while spatial spreading is computed based on
the coordinated of the included population units only.
}
\details{
For each requested sample size \code{n} in n_seq (per stratum), the function returns
a balanced, well-spread and stratified sample. All samples are nested,
so that samples with small n is a (balanced) subset of samples with greater n.
The largest sample (the first iteration) can use pps, and sets inclusion
probabilities \eqn{\pi_i = n \cdot a_i / \sum_{h} a_i} within each stratum
using the \code{area_col} values \eqn{a_i}. Subsequent samples use equal probabilities.
Spatial spreading uses \code{Xspread} (Easting/Northing) and is based on the position of
the remaining population units only. The balancing is, however, always done against the
entire population.

Requires \pkg{BalancedSampling}.
}
\examples{
\dontrun{
# Suppose mypop has: ID, stratum, Easting, Northing, area2, aux1, aux2
# We want nested samples of sizes 100, 80, 60, 40, 20 per stratum:

data(mypop)
out <- nested_balanced(
  data = mypop,
  n_seq = c(100, 80, 60, 40, 20),
  id_col = "ID",
  stratum_col = "stratum",
  easting_col = "Easting",
  northing_col = "Northing",
  area_col = "area2",
  xbal_formula = ~ aux1 + aux2 - 1,
  out_name = "mysample"
)

# Access the largest and a nested subset:
sample_100 <- out$mysample_100
sample_60  <- out$mysample_60
}

}
